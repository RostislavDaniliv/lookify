{% extends 'base.html' %}
{% load static %}

{% block title %}Lookify | Перегляд{% endblock %}

{% block content %}
<section class="py-8 px-4">
    <h1 class="text-4xl font-bold text-textlight text-center mb-10">
        Ваші фото готові до примірки!
    </h1>

    {% if user_photo_url and item_photo_urls %}
        <div class="grid md:grid-cols-2 gap-8 mb-10">
            <!-- User Photo Card -->
            <div class="bg-white/5 p-6 rounded-2xl shadow-soft backdrop-blur-md border border-gray-700 flex flex-col items-center justify-center">
                <h2 class="text-xl font-semibold text-textlight mb-4">Фото користувача</h2>
                <div class="relative w-full max-w-sm aspect-square bg-gray-800 rounded-xl overflow-hidden">
                    <img src="{{ user_photo_url }}" alt="Фото користувача" class="w-full h-full object-cover rounded-xl border border-gray-600">
                </div>
                <!-- <p class="text-sm text-gray-400 mt-3">{{ user_photo_name }} ({{ user_photo_size }} / {{ user_photo_resolution }})</p> -->
            </div>

            <!-- Item Photos Card -->
            <div class="bg-white/5 p-6 rounded-2xl shadow-soft backdrop-blur-md border border-gray-700 flex flex-col items-center justify-center">
                <h2 class="text-xl font-semibold text-textlight mb-4">Фото речі</h2>
                {% for item_url in item_photo_urls %}
                    <div class="relative w-full max-w-sm aspect-square bg-gray-800 rounded-xl overflow-hidden mb-4 last:mb-0">
                        <img class="item-image w-full h-full object-cover rounded-xl border border-gray-600 cursor-crosshair" src="{{ item_url }}" alt="Фото речі {{ forloop.counter }}">
                        <canvas class="selection-canvas absolute inset-0 border-2 border-primary rounded-xl pointer-events-none" data-index="{{ forloop.counter0 }}"></canvas>
                    </div>
                    <!-- <p class="text-sm text-gray-400 mt-3">{{ item_photo_name }} ({{ item_photo_size }} / {{ item_photo_resolution }})</p> -->
                {% endfor %}
            </div>
        </div>

        <!-- Info Banner -->
        <div class="bg-blue-900/20 text-blue-300 p-4 rounded-xl text-center text-sm mb-10 border border-blue-700 backdrop-blur-sm">
            <p>
                <span class="font-semibold">Важливо:</span> Дані обробляються через Lookify. Реальна AI-обробка може тривати до ~15 секунд.
            </p>
        </div>

        <form action="{% url 'process_view' %}" method="post" class="bg-white/5 p-6 rounded-2xl shadow-soft backdrop-blur-md border border-gray-700 text-left mb-10">
            {% csrf_token %}
            <div class="mb-6">
                <label for="additional-prompt" class="block text-textlight text-lg font-semibold mb-2">Додаткові побажання (необов'язково):</label>
                <textarea id="additional-prompt" name="additional_prompt" rows="4" class="w-full p-3 bg-gray-700/50 rounded-lg border border-gray-600 focus:border-primary focus:ring focus:ring-primary focus:ring-opacity-50 text-textlight placeholder-gray-500 transition-all duration-300" placeholder="Опишіть, що б ви хотіли змінити або додати до примірки, наприклад: 'Зробити одяг більш вільним', 'Додати аксесуари'."></textarea>
            </div>
            <input type="hidden" id="selection-mask" name="selection_mask">
            <div class="flex flex-col sm:flex-row justify-center gap-4">
                <a href="{% url 'upload_view' %}" class="flex-1 w-full sm:w-auto px-6 py-3 border border-gray-600 rounded-xl text-textlight hover:border-primary hover:text-primary transition-all duration-300 text-center font-semibold">Змінити фото</a>
                <button type="submit" class="flex-1 w-full sm:w-auto px-6 py-3 bg-gradient-to-r from-primary to-secondary text-white font-bold rounded-xl shadow-lg hover:shadow-neon-primary transition-all duration-300 text-center">Приміряти (Продовжити)</button>
            </div>
        </form>

    {% else %}
        <!-- Empty State -->
        <div class="bg-white/5 p-10 rounded-2xl shadow-soft backdrop-blur-md border border-gray-700 text-center">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-20 h-20 mx-auto mb-6 text-gray-500">
                <path stroke-linecap="round" stroke-linejoin="round" d="M9 13.5h6m-3-3v6m-9 2.25h16.5a2.25 2.25 0 002.25-2.25V6.75A2.25 2.25 0 0018.75 4.5H5.25A2.25 2.25 0 003 6.75v10.5a2.25 2.25 0 002.25 2.25z" />
            </svg>
            <h2 class="text-2xl font-semibold text-textlight mb-4">Немає фотографій для попереднього перегляду</h2>
            <p class="text-gray-400 mb-6">Будь ласка, завантажте ваші фотографії на головній сторінці, щоб продовжити.</p>
            <a href="{% url 'upload_view' %}" class="inline-block px-8 py-3 bg-gradient-to-r from-primary to-secondary text-white font-bold rounded-xl shadow-lg hover:shadow-neon-primary transition-all duration-300">
                Повернутись на головну
            </a>
        </div>
    {% endif %}
</section>

<script>
    const itemImages = document.querySelectorAll('.item-image');
    const canvases = document.querySelectorAll('.selection-canvas');
    const selectionMaskInput = document.getElementById('selection-mask');
    const clearSelectionButton = document.getElementById('clear-selection-button');

    // Store drawing state for each canvas
    const drawingStates = [];

    // Initialize drawing states for each canvas
    canvases.forEach((canvas, index) => {
        drawingStates[index] = {
            isDrawing: false,
            strokes: [],
            currentStroke: []
        };
    });

    function setCanvasSize(canvas, image) {
        canvas.width = image.offsetWidth;
        canvas.height = image.offsetHeight;
        const index = parseInt(canvas.dataset.index);
        redrawPath(canvas, index);
    }

    function initializeCanvas(canvas, image, index) {
        setCanvasSize(canvas, image);
        
        // Programmatically prevent image dragging and selection
        image.addEventListener('dragstart', (e) => e.preventDefault());
        image.addEventListener('selectstart', (e) => e.preventDefault());

        // Add event listeners for this canvas
        canvas.addEventListener('mousedown', (e) => handleMouseDown(e, index));
        canvas.addEventListener('mousemove', (e) => handleMouseMove(e, index));
        canvas.addEventListener('mouseup', () => handleMouseUp(index));
        canvas.addEventListener('mouseleave', () => handleMouseLeave(index));
    }

    // Initialize all canvases
    itemImages.forEach((image, index) => {
        const canvas = canvases[index];
        if (image.complete) {
            initializeCanvas(canvas, image, index);
        } else {
            image.addEventListener('load', () => initializeCanvas(canvas, image, index));
        }
    });

    window.addEventListener('resize', () => {
        itemImages.forEach((image, index) => {
            setCanvasSize(canvases[index], image);
        });
    });

    function getMousePos(e) {
        const canvas = e.target;
        const rect = canvas.getBoundingClientRect();
        return {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
        };
    }

    function redrawPath(canvas, index) {
        const ctx = canvas.getContext('2d');
        const state = drawingStates[index];
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        state.strokes.forEach(stroke => {
            if (stroke.length > 1) {
                ctx.beginPath();
                ctx.moveTo(stroke[0].x, stroke[0].y);
                for (let i = 1; i < stroke.length; i++) {
                    ctx.lineTo(stroke[i].x, stroke[i].y);
                }
                ctx.strokeStyle = '#7C5CFF'; // primary color
                ctx.lineWidth = 3;
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                ctx.setLineDash([]);
                ctx.stroke();
            }
        });
        
        if (state.currentStroke.length > 1) {
            ctx.beginPath();
            ctx.moveTo(state.currentStroke[0].x, state.currentStroke[0].y);
            for (let i = 1; i < state.currentStroke.length; i++) {
                ctx.lineTo(state.currentStroke[i].x, state.currentStroke[i].y);
            }
            ctx.strokeStyle = '#7C5CFF'; // primary color
            ctx.lineWidth = 3;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.setLineDash([]);
            ctx.stroke();
        }
    }

    function generateMask() {
        // Find the first canvas with drawings
        let maskCanvas = null;
        let maskIndex = 0;
        
        for (let i = 0; i < drawingStates.length; i++) {
            const state = drawingStates[i];
            if (state.strokes.length > 0 || state.currentStroke.length > 0) {
                maskCanvas = canvases[i];
                maskIndex = i;
                break;
            }
        }

        if (!maskCanvas) {
            selectionMaskInput.value = '';
            return;
        }

        const state = drawingStates[maskIndex];
        const image = itemImages[maskIndex];

        // Create a temporary canvas with the natural size of the image
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = image.naturalWidth;
        tempCanvas.height = image.naturalHeight;
        const tempCtx = tempCanvas.getContext('2d');

        // Scale the drawing points to the natural image size
        const scaleX = image.naturalWidth / image.offsetWidth;
        const scaleY = image.naturalHeight / image.offsetHeight;

        state.strokes.forEach(stroke => {
            if (stroke.length > 1) {
                tempCtx.beginPath();
                tempCtx.moveTo(stroke[0].x * scaleX, stroke[0].y * scaleY);
                for (let i = 1; i < stroke.length; i++) {
                    tempCtx.lineTo(stroke[i].x * scaleX, stroke[i].y * scaleY);
                }S
                tempCtx.strokeStyle = '#FFFFFF';
                tempCtx.lineWidth = 10;
                tempCtx.lineJoin = 'round';
                tempCtx.lineCap = 'round';
                tempCtx.stroke();
            }
        });

        if (state.currentStroke.length > 1) {
            tempCtx.beginPath();
            tempCtx.moveTo(state.currentStroke[0].x * scaleX, state.currentStroke[0].y * scaleY);
            for (let i = 1; i < state.currentStroke.length; i++) {
                tempCtx.lineTo(state.currentStroke[i].x * scaleX, state.currentStroke[i].y * scaleY);
            }
            tempCtx.strokeStyle = '#FFFFFF';
            tempCtx.lineWidth = 10;
            tempCtx.lineJoin = 'round';
            tempCtx.lineCap = 'round';
            tempCtx.stroke();
        }

        selectionMaskInput.value = tempCanvas.toDataURL('image/png');
    }

    function handleMouseDown(e, index) {
        e.preventDefault();
        const state = drawingStates[index];
        state.isDrawing = true;
        const pos = getMousePos(e);
        state.currentStroke = [{ x: pos.x, y: pos.y }];
        redrawPath(canvases[index], index);
    }

    function handleMouseMove(e, index) {
        const state = drawingStates[index];
        if (!state.isDrawing) return;
        const pos = getMousePos(e);
        state.currentStroke.push({ x: pos.x, y: pos.y });
        redrawPath(canvases[index], index);
    }

    function handleMouseUp(index) {
        const state = drawingStates[index];
        state.isDrawing = false;
        if (state.currentStroke.length > 1) {
            state.strokes.push(state.currentStroke);
            state.currentStroke = [];
        }
        generateMask();
    }

    function handleMouseLeave(index) {
        const state = drawingStates[index];
        state.isDrawing = false;
        if (state.currentStroke.length > 1) {
            state.strokes.push(state.currentStroke);
            state.currentStroke = [];
        }
        generateMask();
    }

    clearSelectionButton.addEventListener('click', () => {
        // Clear all canvases
        canvases.forEach((canvas, index) => {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawingStates[index].strokes = [];
            drawingStates[index].currentStroke = [];
        });
        selectionMaskInput.value = '';
    });

</script>
{% endblock %}
